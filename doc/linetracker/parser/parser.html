<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>linetracker.parser.parser API documentation</title>
<meta name="description" content="Allow to parse the variables and templates using drain parser. Main function is get_parsing_drainparser. Note that if you want the template you can …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>linetracker.parser.parser</code></h1>
</header>
<section id="section-intro">
<p>Allow to parse the variables and templates using drain parser. Main function is get_parsing_drainparser. Note that if you want the template you can make again a function similar to get_parsing_drainparser by using parse and get_templates_variables_per_lines</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Allow to parse the variables and templates using drain parser. Main function is get_parsing_drainparser. Note that if you want the template you can make again a function similar to get_parsing_drainparser by using parse and get_templates_variables_per_lines&#34;&#34;&#34;

import re
from typing import *# type: ignore
import uuid
from collections import OrderedDict

TokenLength = int
Token = str
Wildcard = str
NodeMapping = Dict[Union[TokenLength, Token, Wildcard], &#34;Node&#34;]


class TemplateGroup(TypedDict):
    template: List[str]
    lines: List[Tuple[int, str]]
    id: str

class ParsedLine(TypedDict):
    &#34;&#34;&#34;Represents a parsed line
    
    - template: str, the template of this line
    - variables: List[str], the variables associated with this line
    &#34;&#34;&#34;
    template: str
    variables: List[str]


default_depth: int = 2
default_max_child: int = 3
default_similarity_threshold: float = 0.4


class Logcluster:
    &#34;&#34;&#34;Class to represent log clusters inside tree leaves&#34;&#34;&#34;

    def __init__(self, logTemplate: Optional[List[str]] = None, logIDL=None):
        if logTemplate is None:
            logTemplate = []
        self.logTemplate = logTemplate
        if logIDL is None:
            logIDL = []
        self.logIDL = logIDL
        self.id = str(uuid.uuid4())
    def __str__(self) -&gt; str:
        return f&#34;{self.logTemplate=}\n{self.logIDL=}\n{self.id=}&#34;


class Node:
    &#34;&#34;&#34;
    Class to represent the node of the tree
    # Arguments
    - childD: Optional[Dict[Union[TokenLength, Token, Wildcard],&#34;Node&#34;]], dictionary where the key represents lengths, token or wildcards, Node is the child found in the token
    - depth: int, depth of the current node
    - digitOrtoken: Union[str, int, None], the concrete data represented by the node
    &#34;&#34;&#34;

    def __init__(
        self,
        childD: Optional[Union[NodeMapping, List[Logcluster]]] = None,
        depth=0,
        digitOrtoken: Optional[Union[str, int]] = None,
    ):
        if childD is None:
            childD = dict()
        self.childD: Union[NodeMapping, List[Logcluster]] = childD
        self.depth = depth
        self.digitOrtoken = digitOrtoken


def hasNumbers(s: str) -&gt; bool:
    return any(char.isdigit() for char in s)


def treeSearch(
    rn: Node,
    seq: List[str],
    depth: int = default_depth,
    similarity_threshold: float = default_similarity_threshold,
) -&gt; Optional[Logcluster]:
    &#34;&#34;&#34;Method to search for a sequence &lt;&lt;seq&gt;&gt; inside a node &lt;&lt;rn&gt;&gt;

    # Arguments:
        - rn: Node, root node to start the search from
        - seq: List[str], the sequence of tokens to process
    &#34;&#34;&#34;
    retLogClust = None

    # Quick check by length of the tokens if it is in the root node
    seqLen: TokenLength = len(seq)
    # If not there are no match, so we return None
    if seqLen not in rn.childD:
        return retLogClust

    parentn: Node = rn.childD[seqLen]  # type: ignore

    currentDepth = 1
    for token in seq:
        if currentDepth &gt;= depth or currentDepth &gt; seqLen:
            break

        if token in parentn.childD:
            parentn = parentn.childD[token]  # type: ignore
        elif &#34;&lt;*&gt;&#34; in parentn.childD:
            parentn = parentn.childD[&#34;&lt;*&gt;&#34;]  # type: ignore
        else:
            return retLogClust
        currentDepth += 1

    logClustL = parentn.childD

    retLogClust = fastMatch(logClustL, seq, similarity_threshold=similarity_threshold)

    return retLogClust


def addSeqToPrefixTree(
    rn: Node,
    logClust: Logcluster,
    depth: int = default_depth,
    max_child: int = default_max_child,
):
    &#34;&#34;&#34;Method to add a new sequence as a log cluster to the prefix tree, as it was not found before with treeSearch

    # Arguments:
    - rn: Node, the root node of the file
    - logClust: Logcluster, the new log cluster to add

    &#34;&#34;&#34;
    seqLen = len(logClust.logTemplate)
    ## If we dont have a node representing sequences of the same number of tokens. Then we get this node
    if seqLen not in rn.childD:
        assert isinstance(rn.childD, dict)
        firtLayerNode = Node(depth=1, digitOrtoken=seqLen)
        rn.childD[seqLen] = firtLayerNode
    else:
        firtLayerNode = rn.childD[seqLen]

    parentn = firtLayerNode
    assert isinstance(parentn, Node)
    currentDepth = 1
    for token in logClust.logTemplate:
        ## Add current log cluster to the leaf node
        if currentDepth &gt;= depth or currentDepth &gt; seqLen:
            # assert isinstance(parentn.childD, list)
            if len(parentn.childD) == 0:
                parentn.childD = [logClust]
            else:
                parentn.childD.append(logClust)
            break

        ## If token not matched in this layer of existing tree.
        if token not in parentn.childD:
            assert isinstance(parentn.childD, dict)
            if not hasNumbers(token):
                if &#34;&lt;*&gt;&#34; in parentn.childD:
                    if len(parentn.childD) &lt; max_child:
                        newNode = Node(depth=currentDepth + 1, digitOrtoken=token)
                        parentn.childD[token] = newNode
                        parentn = newNode
                    else:
                        parentn = parentn.childD[&#34;&lt;*&gt;&#34;]
                else:
                    if len(parentn.childD) + 1 &lt; max_child:
                        newNode = Node(depth=currentDepth + 1, digitOrtoken=token)
                        parentn.childD[token] = newNode
                        parentn = newNode
                    elif len(parentn.childD) + 1 == max_child:
                        newNode = Node(depth=currentDepth + 1, digitOrtoken=&#34;&lt;*&gt;&#34;)
                        parentn.childD[&#34;&lt;*&gt;&#34;] = newNode
                        parentn = newNode
                    else:
                        parentn = parentn.childD[&#34;&lt;*&gt;&#34;]

            else:
                if &#34;&lt;*&gt;&#34; not in parentn.childD:
                    newNode = Node(depth=currentDepth + 1, digitOrtoken=&#34;&lt;*&gt;&#34;)
                    parentn.childD[&#34;&lt;*&gt;&#34;] = newNode
                    parentn = newNode
                else:
                    parentn = parentn.childD[&#34;&lt;*&gt;&#34;]

        ## If the token is matched
        else:
            assert isinstance(parentn.childD, dict)
            parentn = parentn.childD[token]

        ## Goes further in depth
        currentDepth += 1


def seqDist(seq1: List[str], seq2: List[str]) -&gt; Tuple[float, int]:
    &#34;&#34;&#34;Method to measure the SimSeq between two sequences seq1 and seq2

    # Return
    - Tuple[float, int]
        - retVal: float, the SimSeq between the two sequences
        - numOfPar: the number of tokens &lt;*&gt;  in seq1
    &#34;&#34;&#34;
    assert len(seq1) == len(seq2)
    simTokens = 0
    numOfPar = 0

    for token1, token2 in zip(seq1, seq2):
        if token1 == &#34;&lt;*&gt;&#34;:
            numOfPar += 1
            continue
        if token1 == token2:
            simTokens += 1

    retVal = float(simTokens) / len(seq1)

    return retVal, numOfPar


def fastMatch(
    logClustL: List[Logcluster],
    seq: List[str],
    similarity_threshold: float = default_similarity_threshold,
) -&gt; Optional[Logcluster]:
    &#34;&#34;&#34;Method to check the maximum similarity threshold between leaves/log clusters.
    Chooses the closest cluster (based on seqDist) for which the template is the closest to seq and above the threshold st

    # Arguments
    - logClustL: List[Logcluster], the clusters to compare the sequence to
    - seq: List[str], the sequence to analyse

    # Returns
    - Optional[Logcluster], either the maximum similarity cluster if above the threshold or None if no cluster found/above the threshold
    &#34;&#34;&#34;
    retLogClust = None

    maxSim = -1
    maxNumOfPara = -1
    maxClust = None

    for logClust in logClustL:
        curSim, curNumOfPara = seqDist(logClust.logTemplate, seq)
        if curSim &gt; maxSim or (curSim == maxSim and curNumOfPara &gt; maxNumOfPara):
            maxSim = curSim
            maxNumOfPara = curNumOfPara
            maxClust = logClust

    if maxSim &gt;= similarity_threshold:
        retLogClust = maxClust

    return retLogClust


def getTemplate(seq1: List[str], seq2: List[str]) -&gt; List[str]:
    &#34;&#34;&#34;Method to get the template of &lt;&lt;seq1&gt;&gt; based on its similar words with seq2

    Example:
    seq1: I love books
    seq2: I love food
    Returns: I love &lt;*&gt;

    # Arguments
    - seq1: List[str], the first sequence to compare
    - seq2: List[str], the second sequence to compare

    # Return
    - List[str], the template, common tokens between the sequences and wildcards &lt;*&gt; for any different tokens
    &#34;&#34;&#34;
    assert len(seq1) == len(seq2)
    retVal = []

    i = 0
    for word in seq1:
        if word == seq2[i]:
            retVal.append(word)
        else:
            retVal.append(&#34;&lt;*&gt;&#34;)

        i += 1

    return retVal


def get_parameter_list(template: str, text: str) -&gt; List[str]:
    &#34;&#34;&#34;Get the list of parameters from the template and the full text&#34;&#34;&#34;
    template_regex = re.sub(r&#34;&lt;.{1,5}&gt;&#34;, &#34;&lt;*&gt;&#34;, template)
    if &#34;&lt;*&gt;&#34; not in template_regex:
        return []
    template_regex = re.sub(r&#34;([^A-Za-z0-9])&#34;, r&#34;\\\1&#34;, template_regex)

    template_regex = re.sub(r&#34;\\\s+&#34;, &#34;\\\s+&#34;, template_regex)  # type: ignore

    template_regex = &#34;^&#34; + template_regex.replace(&#34;\&lt;\*\&gt;&#34;, &#34;(.*?)&#34;) + &#34;$&#34;  # type: ignore
    parameter_list = re.findall(template_regex, text)
    parameter_list = parameter_list[0] if parameter_list else ()
    parameter_list = (
        list(parameter_list) if isinstance(parameter_list, tuple) else [parameter_list]
    )
    return parameter_list


def parse(
    preprocessed_texts: List[str],
    depth: int = default_depth,
    max_child: int = default_max_child,
    similarity_threshold: float = default_similarity_threshold,
) -&gt; Tuple[List[Logcluster], Dict[str, TemplateGroup]]:
    &#34;&#34;&#34;Parse the logs and update the templates iteratively
    
    # Arguments
    - preprocessed_texts: List[str], list of texts preprocessed already
    - depth: int = default_depth, 
    - max_child: int = default_max_child,
    - similarity_threshold: float = default_similarity_threshold,
    &#34;&#34;&#34;
    rootNode = Node()
    logCluL = []
    # prepare the mapping of each template to each line
    templates: Dict[str, TemplateGroup] = {}
    for i, line in enumerate(preprocessed_texts):
        logID = i

        ## Tokenization by splits
        logmessage = line
        logmessageL = logmessage.strip().split()

        matchCluster = treeSearch(
            rootNode,
            logmessageL,
            depth=depth,
            similarity_threshold=similarity_threshold,
        )

        ## Match no existing log cluster
        if matchCluster is None:
            matchCluster = Logcluster(logTemplate=logmessageL, logIDL=[logID])
            logCluL.append(matchCluster)
            addSeqToPrefixTree(rootNode, matchCluster, depth=depth, max_child=max_child)
        ## Adds the new log message to the existing cluster
        else:
            newTemplate = getTemplate(logmessageL, matchCluster.logTemplate)
            matchCluster.logIDL.append(logID)
            if &#34; &#34;.join(newTemplate) != &#34; &#34;.join(matchCluster.logTemplate):
                matchCluster.logTemplate = newTemplate
        # With defaultdict we can directly append the line id to the template list
        if matchCluster.id not in templates:
            templates[matchCluster.id] = TemplateGroup(
                id=matchCluster.id, lines=[], template=matchCluster.logTemplate
            )
        templates[matchCluster.id][&#39;lines&#39;].append((i,line))
        templates[matchCluster.id][&#39;template&#39;] = matchCluster.logTemplate
    return logCluL, templates


def get_templates_variables_per_lines(
    templates: Dict[str, TemplateGroup]
) -&gt; List[ParsedLine]:
    &#34;&#34;&#34;Extract the template and variables associated with each line
    
    # Arguments:
    - templates: Dict[str, TemplateGroup], the generated template object that contains the templates groups
    
    # Return
    - List[ParsedLine], for each line the template and the variables
    &#34;&#34;&#34;
    L = []
    for _, template_group in templates.items():
        template_str = &#34; &#34;.join(template_group[&#34;template&#34;])
        for i, l in template_group[&#34;lines&#34;]:
            L.append({&#34;line_number&#34;: i, &#34;template&#34;:template_str, &#34;variables&#34;:get_parameter_list(template_str, l), &#34;line&#34;:l})
    L.sort(key=lambda x:x[&#39;line_number&#39;])
    return [{&#34;template&#34;: e[&#34;template&#34;], &#34;variables&#34;: e[&#34;variables&#34;]} for e in L]

def preprocess( line: str, rex):
    &#34;&#34;&#34;Method to preprocess file using regex: replace in the line all self.rex regex specified by &lt;*&gt;&#34;&#34;&#34;
    for currentRex in rex:
        line = re.sub(currentRex, &#39;&lt;*&gt;&#39;, line)
    return line

def get_parsing_drainparser(
    events: List[str],
    depth: int = default_depth,
    similarity_threshold: float = default_similarity_threshold,
    max_children: int = default_max_child,
) -&gt; List[ParsedLine]:
    &#34;&#34;&#34;From the list of log lines, returns for each line the emplate and the variables
    
    # Arguments:
    - events: List[str], the list of log lines
    - depth: int = default_depth, the depth of the log tree parser
    - similarity_threshold: float = default_similarity_threshold, the minimum similarity between two lines to create a template, must be between 0 and 1
    - max_children: int = default_max_child, the maximum number of children for one template
    
    # Return
    - List[ParsedLine], for each line the template and the variables
    &#34;&#34;&#34;
    # load the data
    L, templates = parse(
        events,
        depth=depth,
        max_child=max_children,
        similarity_threshold=similarity_threshold,
    )
    variables = get_templates_variables_per_lines(templates)
    return variables</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="linetracker.parser.parser.addSeqToPrefixTree"><code class="name flex">
<span>def <span class="ident">addSeqToPrefixTree</span></span>(<span>rn: <a title="linetracker.parser.parser.Node" href="#linetracker.parser.parser.Node">Node</a>, logClust: <a title="linetracker.parser.parser.Logcluster" href="#linetracker.parser.parser.Logcluster">Logcluster</a>, depth: int = 2, max_child: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to add a new sequence as a log cluster to the prefix tree, as it was not found before with treeSearch</p>
<h1 id="arguments">Arguments:</h1>
<ul>
<li>rn: Node, the root node of the file</li>
<li>logClust: Logcluster, the new log cluster to add</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addSeqToPrefixTree(
    rn: Node,
    logClust: Logcluster,
    depth: int = default_depth,
    max_child: int = default_max_child,
):
    &#34;&#34;&#34;Method to add a new sequence as a log cluster to the prefix tree, as it was not found before with treeSearch

    # Arguments:
    - rn: Node, the root node of the file
    - logClust: Logcluster, the new log cluster to add

    &#34;&#34;&#34;
    seqLen = len(logClust.logTemplate)
    ## If we dont have a node representing sequences of the same number of tokens. Then we get this node
    if seqLen not in rn.childD:
        assert isinstance(rn.childD, dict)
        firtLayerNode = Node(depth=1, digitOrtoken=seqLen)
        rn.childD[seqLen] = firtLayerNode
    else:
        firtLayerNode = rn.childD[seqLen]

    parentn = firtLayerNode
    assert isinstance(parentn, Node)
    currentDepth = 1
    for token in logClust.logTemplate:
        ## Add current log cluster to the leaf node
        if currentDepth &gt;= depth or currentDepth &gt; seqLen:
            # assert isinstance(parentn.childD, list)
            if len(parentn.childD) == 0:
                parentn.childD = [logClust]
            else:
                parentn.childD.append(logClust)
            break

        ## If token not matched in this layer of existing tree.
        if token not in parentn.childD:
            assert isinstance(parentn.childD, dict)
            if not hasNumbers(token):
                if &#34;&lt;*&gt;&#34; in parentn.childD:
                    if len(parentn.childD) &lt; max_child:
                        newNode = Node(depth=currentDepth + 1, digitOrtoken=token)
                        parentn.childD[token] = newNode
                        parentn = newNode
                    else:
                        parentn = parentn.childD[&#34;&lt;*&gt;&#34;]
                else:
                    if len(parentn.childD) + 1 &lt; max_child:
                        newNode = Node(depth=currentDepth + 1, digitOrtoken=token)
                        parentn.childD[token] = newNode
                        parentn = newNode
                    elif len(parentn.childD) + 1 == max_child:
                        newNode = Node(depth=currentDepth + 1, digitOrtoken=&#34;&lt;*&gt;&#34;)
                        parentn.childD[&#34;&lt;*&gt;&#34;] = newNode
                        parentn = newNode
                    else:
                        parentn = parentn.childD[&#34;&lt;*&gt;&#34;]

            else:
                if &#34;&lt;*&gt;&#34; not in parentn.childD:
                    newNode = Node(depth=currentDepth + 1, digitOrtoken=&#34;&lt;*&gt;&#34;)
                    parentn.childD[&#34;&lt;*&gt;&#34;] = newNode
                    parentn = newNode
                else:
                    parentn = parentn.childD[&#34;&lt;*&gt;&#34;]

        ## If the token is matched
        else:
            assert isinstance(parentn.childD, dict)
            parentn = parentn.childD[token]

        ## Goes further in depth
        currentDepth += 1</code></pre>
</details>
</dd>
<dt id="linetracker.parser.parser.fastMatch"><code class="name flex">
<span>def <span class="ident">fastMatch</span></span>(<span>logClustL: List[<a title="linetracker.parser.parser.Logcluster" href="#linetracker.parser.parser.Logcluster">Logcluster</a>], seq: List[str], similarity_threshold: float = 0.4) ‑> Optional[<a title="linetracker.parser.parser.Logcluster" href="#linetracker.parser.parser.Logcluster">Logcluster</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Method to check the maximum similarity threshold between leaves/log clusters.
Chooses the closest cluster (based on seqDist) for which the template is the closest to seq and above the threshold st</p>
<h1 id="arguments">Arguments</h1>
<ul>
<li>logClustL: List[Logcluster], the clusters to compare the sequence to</li>
<li>seq: List[str], the sequence to analyse</li>
</ul>
<h1 id="returns">Returns</h1>
<ul>
<li>Optional[Logcluster], either the maximum similarity cluster if above the threshold or None if no cluster found/above the threshold</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fastMatch(
    logClustL: List[Logcluster],
    seq: List[str],
    similarity_threshold: float = default_similarity_threshold,
) -&gt; Optional[Logcluster]:
    &#34;&#34;&#34;Method to check the maximum similarity threshold between leaves/log clusters.
    Chooses the closest cluster (based on seqDist) for which the template is the closest to seq and above the threshold st

    # Arguments
    - logClustL: List[Logcluster], the clusters to compare the sequence to
    - seq: List[str], the sequence to analyse

    # Returns
    - Optional[Logcluster], either the maximum similarity cluster if above the threshold or None if no cluster found/above the threshold
    &#34;&#34;&#34;
    retLogClust = None

    maxSim = -1
    maxNumOfPara = -1
    maxClust = None

    for logClust in logClustL:
        curSim, curNumOfPara = seqDist(logClust.logTemplate, seq)
        if curSim &gt; maxSim or (curSim == maxSim and curNumOfPara &gt; maxNumOfPara):
            maxSim = curSim
            maxNumOfPara = curNumOfPara
            maxClust = logClust

    if maxSim &gt;= similarity_threshold:
        retLogClust = maxClust

    return retLogClust</code></pre>
</details>
</dd>
<dt id="linetracker.parser.parser.getTemplate"><code class="name flex">
<span>def <span class="ident">getTemplate</span></span>(<span>seq1: List[str], seq2: List[str]) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Method to get the template of &lt;<seq1>&gt; based on its similar words with seq2</p>
<p>Example:
seq1: I love books
seq2: I love food
Returns: I love &lt;*&gt;</p>
<h1 id="arguments">Arguments</h1>
<ul>
<li>seq1: List[str], the first sequence to compare</li>
<li>seq2: List[str], the second sequence to compare</li>
</ul>
<h1 id="return">Return</h1>
<ul>
<li>List[str], the template, common tokens between the sequences and wildcards &lt;*&gt; for any different tokens</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTemplate(seq1: List[str], seq2: List[str]) -&gt; List[str]:
    &#34;&#34;&#34;Method to get the template of &lt;&lt;seq1&gt;&gt; based on its similar words with seq2

    Example:
    seq1: I love books
    seq2: I love food
    Returns: I love &lt;*&gt;

    # Arguments
    - seq1: List[str], the first sequence to compare
    - seq2: List[str], the second sequence to compare

    # Return
    - List[str], the template, common tokens between the sequences and wildcards &lt;*&gt; for any different tokens
    &#34;&#34;&#34;
    assert len(seq1) == len(seq2)
    retVal = []

    i = 0
    for word in seq1:
        if word == seq2[i]:
            retVal.append(word)
        else:
            retVal.append(&#34;&lt;*&gt;&#34;)

        i += 1

    return retVal</code></pre>
</details>
</dd>
<dt id="linetracker.parser.parser.get_parameter_list"><code class="name flex">
<span>def <span class="ident">get_parameter_list</span></span>(<span>template: str, text: str) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of parameters from the template and the full text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parameter_list(template: str, text: str) -&gt; List[str]:
    &#34;&#34;&#34;Get the list of parameters from the template and the full text&#34;&#34;&#34;
    template_regex = re.sub(r&#34;&lt;.{1,5}&gt;&#34;, &#34;&lt;*&gt;&#34;, template)
    if &#34;&lt;*&gt;&#34; not in template_regex:
        return []
    template_regex = re.sub(r&#34;([^A-Za-z0-9])&#34;, r&#34;\\\1&#34;, template_regex)

    template_regex = re.sub(r&#34;\\\s+&#34;, &#34;\\\s+&#34;, template_regex)  # type: ignore

    template_regex = &#34;^&#34; + template_regex.replace(&#34;\&lt;\*\&gt;&#34;, &#34;(.*?)&#34;) + &#34;$&#34;  # type: ignore
    parameter_list = re.findall(template_regex, text)
    parameter_list = parameter_list[0] if parameter_list else ()
    parameter_list = (
        list(parameter_list) if isinstance(parameter_list, tuple) else [parameter_list]
    )
    return parameter_list</code></pre>
</details>
</dd>
<dt id="linetracker.parser.parser.get_parsing_drainparser"><code class="name flex">
<span>def <span class="ident">get_parsing_drainparser</span></span>(<span>events: List[str], depth: int = 2, similarity_threshold: float = 0.4, max_children: int = 3) ‑> List[<a title="linetracker.parser.parser.ParsedLine" href="#linetracker.parser.parser.ParsedLine">ParsedLine</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>From the list of log lines, returns for each line the emplate and the variables</p>
<h1 id="arguments">Arguments:</h1>
<ul>
<li>events: List[str], the list of log lines</li>
<li>depth: int = default_depth, the depth of the log tree parser</li>
<li>similarity_threshold: float = default_similarity_threshold, the minimum similarity between two lines to create a template, must be between 0 and 1</li>
<li>max_children: int = default_max_child, the maximum number of children for one template</li>
</ul>
<h1 id="return">Return</h1>
<ul>
<li>List[ParsedLine], for each line the template and the variables</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parsing_drainparser(
    events: List[str],
    depth: int = default_depth,
    similarity_threshold: float = default_similarity_threshold,
    max_children: int = default_max_child,
) -&gt; List[ParsedLine]:
    &#34;&#34;&#34;From the list of log lines, returns for each line the emplate and the variables
    
    # Arguments:
    - events: List[str], the list of log lines
    - depth: int = default_depth, the depth of the log tree parser
    - similarity_threshold: float = default_similarity_threshold, the minimum similarity between two lines to create a template, must be between 0 and 1
    - max_children: int = default_max_child, the maximum number of children for one template
    
    # Return
    - List[ParsedLine], for each line the template and the variables
    &#34;&#34;&#34;
    # load the data
    L, templates = parse(
        events,
        depth=depth,
        max_child=max_children,
        similarity_threshold=similarity_threshold,
    )
    variables = get_templates_variables_per_lines(templates)
    return variables</code></pre>
</details>
</dd>
<dt id="linetracker.parser.parser.get_templates_variables_per_lines"><code class="name flex">
<span>def <span class="ident">get_templates_variables_per_lines</span></span>(<span>templates: Dict[str, <a title="linetracker.parser.parser.TemplateGroup" href="#linetracker.parser.parser.TemplateGroup">TemplateGroup</a>]) ‑> List[<a title="linetracker.parser.parser.ParsedLine" href="#linetracker.parser.parser.ParsedLine">ParsedLine</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the template and variables associated with each line</p>
<h1 id="arguments">Arguments:</h1>
<ul>
<li>templates: Dict[str, TemplateGroup], the generated template object that contains the templates groups</li>
</ul>
<h1 id="return">Return</h1>
<ul>
<li>List[ParsedLine], for each line the template and the variables</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_templates_variables_per_lines(
    templates: Dict[str, TemplateGroup]
) -&gt; List[ParsedLine]:
    &#34;&#34;&#34;Extract the template and variables associated with each line
    
    # Arguments:
    - templates: Dict[str, TemplateGroup], the generated template object that contains the templates groups
    
    # Return
    - List[ParsedLine], for each line the template and the variables
    &#34;&#34;&#34;
    L = []
    for _, template_group in templates.items():
        template_str = &#34; &#34;.join(template_group[&#34;template&#34;])
        for i, l in template_group[&#34;lines&#34;]:
            L.append({&#34;line_number&#34;: i, &#34;template&#34;:template_str, &#34;variables&#34;:get_parameter_list(template_str, l), &#34;line&#34;:l})
    L.sort(key=lambda x:x[&#39;line_number&#39;])
    return [{&#34;template&#34;: e[&#34;template&#34;], &#34;variables&#34;: e[&#34;variables&#34;]} for e in L]</code></pre>
</details>
</dd>
<dt id="linetracker.parser.parser.hasNumbers"><code class="name flex">
<span>def <span class="ident">hasNumbers</span></span>(<span>s: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasNumbers(s: str) -&gt; bool:
    return any(char.isdigit() for char in s)</code></pre>
</details>
</dd>
<dt id="linetracker.parser.parser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>preprocessed_texts: List[str], depth: int = 2, max_child: int = 3, similarity_threshold: float = 0.4) ‑> Tuple[List[<a title="linetracker.parser.parser.Logcluster" href="#linetracker.parser.parser.Logcluster">Logcluster</a>], Dict[str, <a title="linetracker.parser.parser.TemplateGroup" href="#linetracker.parser.parser.TemplateGroup">TemplateGroup</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the logs and update the templates iteratively</p>
<h1 id="arguments">Arguments</h1>
<ul>
<li>preprocessed_texts: List[str], list of texts preprocessed already</li>
<li>depth: int = default_depth, </li>
<li>max_child: int = default_max_child,</li>
<li>similarity_threshold: float = default_similarity_threshold,</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(
    preprocessed_texts: List[str],
    depth: int = default_depth,
    max_child: int = default_max_child,
    similarity_threshold: float = default_similarity_threshold,
) -&gt; Tuple[List[Logcluster], Dict[str, TemplateGroup]]:
    &#34;&#34;&#34;Parse the logs and update the templates iteratively
    
    # Arguments
    - preprocessed_texts: List[str], list of texts preprocessed already
    - depth: int = default_depth, 
    - max_child: int = default_max_child,
    - similarity_threshold: float = default_similarity_threshold,
    &#34;&#34;&#34;
    rootNode = Node()
    logCluL = []
    # prepare the mapping of each template to each line
    templates: Dict[str, TemplateGroup] = {}
    for i, line in enumerate(preprocessed_texts):
        logID = i

        ## Tokenization by splits
        logmessage = line
        logmessageL = logmessage.strip().split()

        matchCluster = treeSearch(
            rootNode,
            logmessageL,
            depth=depth,
            similarity_threshold=similarity_threshold,
        )

        ## Match no existing log cluster
        if matchCluster is None:
            matchCluster = Logcluster(logTemplate=logmessageL, logIDL=[logID])
            logCluL.append(matchCluster)
            addSeqToPrefixTree(rootNode, matchCluster, depth=depth, max_child=max_child)
        ## Adds the new log message to the existing cluster
        else:
            newTemplate = getTemplate(logmessageL, matchCluster.logTemplate)
            matchCluster.logIDL.append(logID)
            if &#34; &#34;.join(newTemplate) != &#34; &#34;.join(matchCluster.logTemplate):
                matchCluster.logTemplate = newTemplate
        # With defaultdict we can directly append the line id to the template list
        if matchCluster.id not in templates:
            templates[matchCluster.id] = TemplateGroup(
                id=matchCluster.id, lines=[], template=matchCluster.logTemplate
            )
        templates[matchCluster.id][&#39;lines&#39;].append((i,line))
        templates[matchCluster.id][&#39;template&#39;] = matchCluster.logTemplate
    return logCluL, templates</code></pre>
</details>
</dd>
<dt id="linetracker.parser.parser.preprocess"><code class="name flex">
<span>def <span class="ident">preprocess</span></span>(<span>line: str, rex)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to preprocess file using regex: replace in the line all self.rex regex specified by &lt;*&gt;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess( line: str, rex):
    &#34;&#34;&#34;Method to preprocess file using regex: replace in the line all self.rex regex specified by &lt;*&gt;&#34;&#34;&#34;
    for currentRex in rex:
        line = re.sub(currentRex, &#39;&lt;*&gt;&#39;, line)
    return line</code></pre>
</details>
</dd>
<dt id="linetracker.parser.parser.seqDist"><code class="name flex">
<span>def <span class="ident">seqDist</span></span>(<span>seq1: List[str], seq2: List[str]) ‑> Tuple[float, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Method to measure the SimSeq between two sequences seq1 and seq2</p>
<h1 id="return">Return</h1>
<ul>
<li>Tuple[float, int]<ul>
<li>retVal: float, the SimSeq between the two sequences</li>
<li>numOfPar: the number of tokens &lt;*&gt;
in seq1</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seqDist(seq1: List[str], seq2: List[str]) -&gt; Tuple[float, int]:
    &#34;&#34;&#34;Method to measure the SimSeq between two sequences seq1 and seq2

    # Return
    - Tuple[float, int]
        - retVal: float, the SimSeq between the two sequences
        - numOfPar: the number of tokens &lt;*&gt;  in seq1
    &#34;&#34;&#34;
    assert len(seq1) == len(seq2)
    simTokens = 0
    numOfPar = 0

    for token1, token2 in zip(seq1, seq2):
        if token1 == &#34;&lt;*&gt;&#34;:
            numOfPar += 1
            continue
        if token1 == token2:
            simTokens += 1

    retVal = float(simTokens) / len(seq1)

    return retVal, numOfPar</code></pre>
</details>
</dd>
<dt id="linetracker.parser.parser.treeSearch"><code class="name flex">
<span>def <span class="ident">treeSearch</span></span>(<span>rn: <a title="linetracker.parser.parser.Node" href="#linetracker.parser.parser.Node">Node</a>, seq: List[str], depth: int = 2, similarity_threshold: float = 0.4) ‑> Optional[<a title="linetracker.parser.parser.Logcluster" href="#linetracker.parser.parser.Logcluster">Logcluster</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Method to search for a sequence &lt;<seq>&gt; inside a node &lt;<rn>&gt;</p>
<h1 id="arguments">Arguments:</h1>
<pre><code>- rn: Node, root node to start the search from
- seq: List[str], the sequence of tokens to process
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def treeSearch(
    rn: Node,
    seq: List[str],
    depth: int = default_depth,
    similarity_threshold: float = default_similarity_threshold,
) -&gt; Optional[Logcluster]:
    &#34;&#34;&#34;Method to search for a sequence &lt;&lt;seq&gt;&gt; inside a node &lt;&lt;rn&gt;&gt;

    # Arguments:
        - rn: Node, root node to start the search from
        - seq: List[str], the sequence of tokens to process
    &#34;&#34;&#34;
    retLogClust = None

    # Quick check by length of the tokens if it is in the root node
    seqLen: TokenLength = len(seq)
    # If not there are no match, so we return None
    if seqLen not in rn.childD:
        return retLogClust

    parentn: Node = rn.childD[seqLen]  # type: ignore

    currentDepth = 1
    for token in seq:
        if currentDepth &gt;= depth or currentDepth &gt; seqLen:
            break

        if token in parentn.childD:
            parentn = parentn.childD[token]  # type: ignore
        elif &#34;&lt;*&gt;&#34; in parentn.childD:
            parentn = parentn.childD[&#34;&lt;*&gt;&#34;]  # type: ignore
        else:
            return retLogClust
        currentDepth += 1

    logClustL = parentn.childD

    retLogClust = fastMatch(logClustL, seq, similarity_threshold=similarity_threshold)

    return retLogClust</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="linetracker.parser.parser.Logcluster"><code class="flex name class">
<span>class <span class="ident">Logcluster</span></span>
<span>(</span><span>logTemplate: Optional[List[str]] = None, logIDL=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent log clusters inside tree leaves</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Logcluster:
    &#34;&#34;&#34;Class to represent log clusters inside tree leaves&#34;&#34;&#34;

    def __init__(self, logTemplate: Optional[List[str]] = None, logIDL=None):
        if logTemplate is None:
            logTemplate = []
        self.logTemplate = logTemplate
        if logIDL is None:
            logIDL = []
        self.logIDL = logIDL
        self.id = str(uuid.uuid4())
    def __str__(self) -&gt; str:
        return f&#34;{self.logTemplate=}\n{self.logIDL=}\n{self.id=}&#34;</code></pre>
</details>
</dd>
<dt id="linetracker.parser.parser.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>childD: Union[Dict[Union[int, str], ForwardRef('<a title="linetracker.parser.parser.Node" href="#linetracker.parser.parser.Node">Node</a>')], List[<a title="linetracker.parser.parser.Logcluster" href="#linetracker.parser.parser.Logcluster">Logcluster</a>], ForwardRef(None)] = None, depth=0, digitOrtoken: Union[str, int, ForwardRef(None)] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent the node of the tree</p>
<h1 id="arguments">Arguments</h1>
<ul>
<li>childD: Optional[Dict[Union[TokenLength, Token, Wildcard],"Node"]], dictionary where the key represents lengths, token or wildcards, Node is the child found in the token</li>
<li>depth: int, depth of the current node</li>
<li>digitOrtoken: Union[str, int, None], the concrete data represented by the node</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node:
    &#34;&#34;&#34;
    Class to represent the node of the tree
    # Arguments
    - childD: Optional[Dict[Union[TokenLength, Token, Wildcard],&#34;Node&#34;]], dictionary where the key represents lengths, token or wildcards, Node is the child found in the token
    - depth: int, depth of the current node
    - digitOrtoken: Union[str, int, None], the concrete data represented by the node
    &#34;&#34;&#34;

    def __init__(
        self,
        childD: Optional[Union[NodeMapping, List[Logcluster]]] = None,
        depth=0,
        digitOrtoken: Optional[Union[str, int]] = None,
    ):
        if childD is None:
            childD = dict()
        self.childD: Union[NodeMapping, List[Logcluster]] = childD
        self.depth = depth
        self.digitOrtoken = digitOrtoken</code></pre>
</details>
</dd>
<dt id="linetracker.parser.parser.ParsedLine"><code class="flex name class">
<span>class <span class="ident">ParsedLine</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a parsed line</p>
<ul>
<li>template: str, the template of this line</li>
<li>variables: List[str], the variables associated with this line</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParsedLine(TypedDict):
    &#34;&#34;&#34;Represents a parsed line
    
    - template: str, the template of this line
    - variables: List[str], the variables associated with this line
    &#34;&#34;&#34;
    template: str
    variables: List[str]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="linetracker.parser.parser.ParsedLine.template"><code class="name">var <span class="ident">template</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="linetracker.parser.parser.ParsedLine.variables"><code class="name">var <span class="ident">variables</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="linetracker.parser.parser.TemplateGroup"><code class="flex name class">
<span>class <span class="ident">TemplateGroup</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TemplateGroup(TypedDict):
    template: List[str]
    lines: List[Tuple[int, str]]
    id: str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="linetracker.parser.parser.TemplateGroup.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="linetracker.parser.parser.TemplateGroup.lines"><code class="name">var <span class="ident">lines</span> : List[Tuple[int, str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="linetracker.parser.parser.TemplateGroup.template"><code class="name">var <span class="ident">template</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="linetracker.parser" href="index.html">linetracker.parser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="linetracker.parser.parser.addSeqToPrefixTree" href="#linetracker.parser.parser.addSeqToPrefixTree">addSeqToPrefixTree</a></code></li>
<li><code><a title="linetracker.parser.parser.fastMatch" href="#linetracker.parser.parser.fastMatch">fastMatch</a></code></li>
<li><code><a title="linetracker.parser.parser.getTemplate" href="#linetracker.parser.parser.getTemplate">getTemplate</a></code></li>
<li><code><a title="linetracker.parser.parser.get_parameter_list" href="#linetracker.parser.parser.get_parameter_list">get_parameter_list</a></code></li>
<li><code><a title="linetracker.parser.parser.get_parsing_drainparser" href="#linetracker.parser.parser.get_parsing_drainparser">get_parsing_drainparser</a></code></li>
<li><code><a title="linetracker.parser.parser.get_templates_variables_per_lines" href="#linetracker.parser.parser.get_templates_variables_per_lines">get_templates_variables_per_lines</a></code></li>
<li><code><a title="linetracker.parser.parser.hasNumbers" href="#linetracker.parser.parser.hasNumbers">hasNumbers</a></code></li>
<li><code><a title="linetracker.parser.parser.parse" href="#linetracker.parser.parser.parse">parse</a></code></li>
<li><code><a title="linetracker.parser.parser.preprocess" href="#linetracker.parser.parser.preprocess">preprocess</a></code></li>
<li><code><a title="linetracker.parser.parser.seqDist" href="#linetracker.parser.parser.seqDist">seqDist</a></code></li>
<li><code><a title="linetracker.parser.parser.treeSearch" href="#linetracker.parser.parser.treeSearch">treeSearch</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="linetracker.parser.parser.Logcluster" href="#linetracker.parser.parser.Logcluster">Logcluster</a></code></h4>
</li>
<li>
<h4><code><a title="linetracker.parser.parser.Node" href="#linetracker.parser.parser.Node">Node</a></code></h4>
</li>
<li>
<h4><code><a title="linetracker.parser.parser.ParsedLine" href="#linetracker.parser.parser.ParsedLine">ParsedLine</a></code></h4>
<ul class="">
<li><code><a title="linetracker.parser.parser.ParsedLine.template" href="#linetracker.parser.parser.ParsedLine.template">template</a></code></li>
<li><code><a title="linetracker.parser.parser.ParsedLine.variables" href="#linetracker.parser.parser.ParsedLine.variables">variables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="linetracker.parser.parser.TemplateGroup" href="#linetracker.parser.parser.TemplateGroup">TemplateGroup</a></code></h4>
<ul class="">
<li><code><a title="linetracker.parser.parser.TemplateGroup.id" href="#linetracker.parser.parser.TemplateGroup.id">id</a></code></li>
<li><code><a title="linetracker.parser.parser.TemplateGroup.lines" href="#linetracker.parser.parser.TemplateGroup.lines">lines</a></code></li>
<li><code><a title="linetracker.parser.parser.TemplateGroup.template" href="#linetracker.parser.parser.TemplateGroup.template">template</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>